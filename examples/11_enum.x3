import "./lib/standard" use standard

enum action {
    idle,
    move[x:int,y:int],
    heal[amount:int],
}

enum type[name:string,size:int] {
	number[signed:bool],
	pointer[to:~>type],
}

proc print action[action:action] {
    match action {
        idle {
            write line("idle")
        }
        move: m {
            write("move(")
            write number(m.x)
            write(", ")
            write number(m.y)
            write(")\n")
        }
        heal: h {
            write("heal(")
            write number(h.amount)
            write line(")")
        }
    }
}

proc main[] {
    // var a = action.idle
    // var b = action.move(10,20)
    // var c = action.heal(48)

    // println(a)
    // println(b)
    // println(c)

    // if c == heal:h {
    //     write("heal ")
    //     write number(h.amount)
    //     write("!\n")
    // } else {
    //     write line("It's not heal")
    // }

    // assert(b==move:m, "b is a move")

    // write number(m.x)
    // write(", ")
    // write number(m.y)
    // write("\n")

    // m.x=45
    // m.y=68

    // print action(a)
    // print action(b)
    // print action(c)

	var i  = type.number (name="int",     size=8, signed=true)
	var u  = type.number (name="uint",    size=8, signed=false)
	var pi = type.pointer(name="pointer", size=8, to=~>i)
	var pu = type.pointer(name="pointer", size=8, to=~>u)

    printf("%: %\n", i.name, i.size)
    printf("%: %\n", u.name, u.size)
    printf("%: %\n", pi.name, pi.size)
    printf("%: %\n", pu.name, pu.size)

    // write line("match:")
    // match c {
    //     red     { write line("red") }
    //     green   { write line("green") }
    //     blue    { write line("blue") }
    // }
    // write line("-----")
}

    // TODO: fix foo(color.red,"bob",7) not working unless enum already emitted type info

    // // TODO: make print work with string literals
    // write line("--------")
    // println(839)
    // println(183)
    // println(1)
    // println(0)
