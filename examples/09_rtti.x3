import "./lib/standard" use standard

struct point[x:int,y:int]
struct person[name:string,age:int,gender:string]
struct complex[entity:person,pos:point]

proc write type[t:->type info] {
    const tag void    = 0
    const tag int     = 1
    const tag bool    = 2
    const tag string  = 3
    const tag char    = 4
    const tag pointer = 5
    const tag array   = 6
    const tag struct  = 7
    const tag type    = 8

    if t.kind == tag struct {
        write ("struct ")
    }

    // write number(t.size)
    // write("::")
    write(t.name)

    if t.kind == tag int {
        write("(")
        if t.data.intData.signed {
            write("signed")
        } else {
            write("unsigned")
        }
        write(")")
    } else if t.kind == tag pointer {
        write("<")
        write type(t.data.pointerData.to)
        write(">")
    } else if t.kind == tag array {
        write("[")
        if (t.data.arrayData.count > 0) {
            write number(t.data.arrayData.count)
        }
        write("]")
        write type(t.data.arrayData.of)
    } else if t.kind == tag struct {
        write(" {\n")
        // TODO: property access from array (foo[0].bar)
        // TODO: allow property in each loop
        var fields = t.data.structData.fields

        each field : fields {
            write("  ")
            write number(field.offset)
            write("->")
            write(field.name)
            write(":")
            write type(field.type)
            write("\n")
        }
        write("}")
    }
}

// TODO: some allocation scheme so we can return this as a string
proc to json[it:any] {
    proc pad[padding:int] {
        for var i = 0; i < padding; i++ {
            write char(" ") 
        }
    }

    proc to json internal[it:any,padding:int,use padding:bool] {
        if use padding {
            pad(padding)
        }

        // TODO: make an enum out of this 
        const tag void    = 0
        const tag int     = 1
        const tag bool    = 2
        const tag string  = 3
        const tag char    = 4
        const tag pointer = 5
        const tag array   = 6
        const tag struct  = 7
        const tag type    = 8

        var d = it.data
        // TODO: fix pointer following for nested property access
        var t = it.type

        if t.kind == tag int {
            write number(<-d)
        } else if t.kind == tag string {
            write("\"")
            write(<-d)
            write("\"")
        } else if t.kind == tag pointer {
            panic("pointers cannot be serialized")
        } else if t.kind == tag array {
            var entries:[]void = <-d
            var entryType = t.data.arrayData.of
            var entrySize = entryType.size
            var is complex = (entries.length > 12) || ((entryType.kind != tag int) && (entries.length > 1))

            // TODO: fix if and else statement having the same scope?
            var i = 0
            if is complex {
                write("[\n")

                while(i<entries.length) {
                    var ptr = entries.buffer + (i * entrySize)
                    to json internal(any(ptr,entryType),padding+4,true)
                    if i != (entries.length-1) {
                        write(",")
                    }
                    write("\n")
                    i++
                }
                write("]")
            } else {
                write("[")

                while(i<entries.length) {
                    var ptr = entries.buffer + (i * entrySize)
                    to json internal(any(ptr,entryType),padding,false)
                    if i != (entries.length-1) {
                        write(", ")
                    }
                    i++
                }
                write("]")
            }

        } else if t.kind == tag struct {
            var basePtr = d
            var fields = t.data.structData.fields
            // TODO: 'fix is complex = field.length>4' not working for some reason
            var is complex = false
            if fields.length > 4 {
                is complex = true
            } else {
                each field : fields {
                    var fieldType = field.type
                    if (field.name.length > 12) {
                        is complex = true
                        break
                    }
                    if (fieldType.kind != tag int) {
                        is complex = true
                        break
                    }
                }
            }

            if is complex {
                write("{\n")
                each field,i : fields {
                    var fieldPtr = basePtr + field.offset
                    var fieldType = field.type
                    pad(padding+4)
                    write("\"")
                    write(field.name)
                    write("\"")
                    write(": ")
                    to json internal(any(fieldPtr, fieldType), padding+4,false)
                    if (i != (fields.length-1)) {
                        write(",\n")
                    } else {
                        write("\n")
                    }
                }
                pad(padding)
                write("}")
            } else {
                write("{")
                each field,i : fields {
                    var fieldPtr = basePtr + field.offset
                    var fieldType = field.type
                    write("\"")
                    write(field.name)
                    write("\"")
                    write(": ")
                    to json internal(any(fieldPtr, fieldType), padding,false)
                    if (i != (fields.length-1)) {
                        write(", ")
                    }
                }
                write("}")
            }
        } else {
            write number(t.kind)
            panic("Unsupported type tag")
        }
    }

    to json internal(it,0,false)
    write("\n")
}

proc main {
    var str = "hello rtti"
    var num = -42
    var unum:u64 = 20
    var sptr = ->str
    var nptr = ->num
    var uptr = ->unum
    var num list = [10,20,30]
    var str list = ["foo","bar","baz"]
    var p = point(32,45)
    var me = person("ivy", 23, "male")
    var c = complex(me,p)

    // TODO: fix const being broken

    // what's broken
    // - .data section consts just assume everything is a qword currently; firgure out how to switch to other sizes so we can properly do bools and chars
    write type(typeof(str)) write("\n")
    write type(typeof(num)) write("\n")
    write type(typeof(sptr)) write("\n")
    write type(typeof(nptr)) write("\n")
    write type(typeof(uptr)) write("\n")
    write type(typeof(num list)) write("\n")
    write type(typeof(str list)) write("\n")
    write type(typeof(p)) write("\n")
    write type(typeof(me)) write("\n")

    println(num)
    println(str)
    println(sptr)
    println(nptr)
    println(uptr)
    println(num list)
    println(str list)
    println(p)
    println(me)

    write line("json gang:")
    to json(num)
    to json(str)
    to json(num list)
    to json(str list)
    to json(p)
    to json(me)
    to json(c)
    write line("ÁßÅ„ÅØÁå´„Åå„É©„Éñüò≠üêæ")
}
