import "./lib/standard" use standard

struct any [
    data:->void,
    'type:->'type info'
]

proc println[it:any] {
    // TODO: allow unary on property
    // TODO: better symbol parser;
    //   allow keyword at start of symbol name if we KNOW we're expecting a symbol
    //   this saves us from doing 'type all over the place
    var data = it.data
    if (it.'type.kind == 1) { // int
        write number(<-data)
    } else {
        assert(it.'type.kind == 3) // string
        write(<-data)
    }
    write("\n")
}

proc write type[t:->'type info'] {
    const tag_void    = 0
    const tag_int     = 1
    const tag_bool    = 2
    const tag_string  = 3
    const tag_char    = 4
    const tag_pointer = 5
    const tag_array   = 6
    const tag_struct  = 7
    const tag_type    = 8

    write(t.name)
    write(" :: ")
    write number(t.size)

    if t.kind == tag_int {
        write(" (")
        if t.data.intData.signed {
            write("signed")
        } else {
            write("unsigned")
        }
        write(")")
    } else if t.kind == tag_array {
        // write(" [")
        // write number(t.data.arrayData.count)
        // write("] ")
        // write type(t.data.arrayData.of)
    } else if t.kind == tag_struct {
        write(" {\n")
        // TODO: allow property in each loop
        // var fields = t.data.structData.fields
        // each field :  fields {
        //     write number(field.offset)
        //     write(" -> ")
        //     write(field.name)
        //     write(": ")
        //     write type(field.'type')
        // }
        // write("}")
    }
    write("\n")
}

proc main {
    var str = "hello rtti"
    var num = 42
    write type(typeof(str))
    write type(typeof(num))

    // TODO: fix these!
    // println(any(->str,typeof(str)))
    // println(any(->num,typeof(num)))
}
