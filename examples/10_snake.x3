import "./lib/standard" use standard

proc main {
	play snake()
}

proc play snake {
	var termState = sys.fcntl(sys.stdin, sys.F_GETFL,0)
	sys.fcntl(sys.stdin, sys.F_SETFL, termState | sys.O_NONBLOCK)

	const board size = 16
	var apple = 0
	var snake = 0
	var key:[2]char // NOTE: it's 2 characters because otherwise it will buffer and return the buffered character
	// var snake:[board size * board size]int

	proc random position() -> int { return random range(0,board size * board size) }
	proc place(at:int,it:any) {
		var x = at%board size
		var y = at/board size
		tui.cursor to(x,y)
		printf("%",it)
		// printf("%%,%:%",it,x,y,at)
	}

	tui.clear()

	each y <- board size {
		each x <- board size {
			write("_")
		}
		write("\n")
	}

	snake = board size * board size / 2
	apple = random position()

	place(apple, format.red("*"))

	enum direction { up, down, left, right }
	var dir = direction.up

	while true {
		tui.cursor to(0, board size+1)
		sleep(.2)
		read(key)

		//place(snake, "_")

		if (key[0] == "w") {
			dir=direction.up
		} else if key[0] == "a" {
			dir=direction.left
		} else if key[0] == "s" {
			dir=direction.down
		} else if key[0] == "d" {
			dir=direction.right
		}

		match dir {
			up {
				if snake < board size'  break
				snake -= board size
			}
			left {
				if snake % board size == 0  break
				snake -= 1
			}
			down {
				if snake + board size >= (board size * board size)  break
				snake += board size
			}
			right {
				if (snake+1) % board size == 0  break
				snake += 1
			}
		}

		place(snake, format.cyan("#"))
	}

	tui.cursor to(0, board size+1)
	write("Game over!\n")

	sys.fcntl(sys.stdin, sys.F_SETFL, termState)

	// // TODO: read board size constant from outer scope
	// proc random position() -> int { return random range(0,100+1) }

	// // TODO: constants in array size (arr:[10][10]char)
	// // TODO: multi dimensional arrays
	// // TODO: constant arrays
	// // TODO: initializer syntax; board:[100]char = ["a","b",..."c"] // a then b then fill the rest with c (otherwise it would be filled with 0)
	// var board: [100]char

	// var score = 0
	// var apple pos = random position()
	// var player pos = random position()
	// var key err = false 

	// // TODO: make goto work when the label is in another block (don't jump into scope blocks though)
	// // we always want to render once before taking user input
	// goto render

	// label game loop:
	// do update(player pos:int,apple pos:int,score:int, key err:!bool) {
	// 	key err = false
	// 	var key:[2]char // NOTE: it's 2 characters because otherwise it will buffer and return the buffered character
	// 	read(key)
	// 	// TODO: handle wrapping
	// 	if (key[0] == "w") {
	// 		player pos -= 10
	// 	} else if key[0] == "a" {
	// 		player pos -= 1
	// 	} else if key[0] == "s" {
	// 		player pos += 10
	// 	} else if key[0] == "d" {
	// 		player pos += 1
	// 	} else {
	// 		key err = true
	// 		// TODO: find lab
	// 		// goto game loop
	// 	}

	// 	if apple pos == player pos {
	// 		score++
	// 		// TODO: allow scopes to access FUNCTIONS from the outer scope, but not variables
	// 		apple pos = random range(0,101) //random position()
	// 	}
	// }

	// label render:
	// do render(board:[]char, apple pos:int,player pos:int,score:int, key err:bool) {
	// 	tui.clear()
	// 	tui.cursor to(0,5)
	// 	// tui.clear()
	// 	const apple:char = "*"
	// 	const body:char = "#"
	// 	const floor:char = "_"

	// 	// TODO: make this more efficient; keep track of last player position and only update the characters that changed
	// 	each _,i <- board { board[i] = floor }
	// 	board[player pos] = body
	// 	board[apple pos] = apple

	// 	printf("Score: %\n", format.green(score))

	// 	each cell,i <- board {
	// 		var color = tui.color.white
	// 		if cell == apple {
	// 			color = tui.color.red
	// 		} else if cell == body {
	// 			color = tui.color.cyan
	// 		}

	// 		write(color)
	// 		write char(cell)

	// 		if (i+1) % 10 == 0 {
	// 			write("\n")
	// 		}
	// 	}
	// 	write(tui.color.reset)

	// 	if key err {
	// 		printf("%\n", format.yellow("unkown key; use wasd to move"))
	// 	}
	// }

	// if score < 10 goto game loop

	// tui.cursor to(0,13)
	// write("*********************************\n")
	// write("*            You win!           *\n")
	// write("*********************************\n")
}
