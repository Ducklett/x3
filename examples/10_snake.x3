import "./lib/standard" use standard

proc main {
	play snake()
}

// a basic snake game
// works best with unbuffered inputs but-
// we can't control that yet.
// for now the `make snake` is used to start the game
proc play snake {
	var termState = sys.fcntl(sys.stdin, sys.F_GETFL,0)
	sys.fcntl(sys.stdin, sys.F_SETFL, termState | sys.O_NONBLOCK)

	const board size = 16
	const board area = board size * board size

	var apple = 0
	// TODO: constant folding for array size (board size * board size)
	var snake:[256]int
	var board:[256]char

	each _,i <- board { board[i] = "_" }

	var score = 0
	var index = 0

	var key:[2]char // NOTE: it's 2 characters because otherwise it will buffer and return the buffered character

	proc random position() -> int { return random range(0,board area) }

	tui.clear()

	snake[index] = board area / 2 + (board size / 2)
	apple = 40 //random position()

	board[apple] = "*"
	board[snake[index]] = "#"

	enum direction { up, down, left, right }
	var dir = direction.up

	while true {
		tui.cursor to(0, board size+1)
		sleep(.2)
		read(key)

		match key[0] {
			"w"    dir = direction.up
			"a"    dir = direction.left
			"s"    dir = direction.down
			"d"    dir = direction.right
		}

		var prev = snake[index]
		index = (index + 1) % board area

		match dir {
			up {
				if prev < board size'  break
				snake[index] = prev - board size
			}
			left {
				if prev % board size == 0  break
				snake[index] = prev - 1
			}
			down {
				if prev + board size >= board area'  break
				snake[index] = prev + board size
			}
			right {
				if (prev+1) % board size == 0  break
				snake[index] = prev + 1
			}
		}

		// self collision
		if board[snake[index]] == "#" break

		if snake[index] == apple {
			score++
			// TODO: fix random giving us broken numbers
			// TODO: fix number printer suppoedly printing them wrong
			// TODO: fix array access for these broken numbers?

			// prng for now
			apple = apple + 37 * 45839 % board area //random position()
		}

		var toRemove = index - (score + 1) + board area % board area
		board[snake[toRemove]] = "_"
		board[snake[index]] = "#"

		board[apple] = "*"

		tui.cursor to(0,0)
		each y <- board size {
			each x <- board size {
				write char(board[x+(y*board size)])
			}
			tui.cursor to(0,y+1)
		}

		tui.cursor to(0, board size+1)
		print(apple)
	}

	tui.cursor to(0, board size+1)
	write("Game over!\n")

	// grab input for a little bit longer so-
	// we don't spam random keys into the console on game over
	sleep(1)
	read(key)

	sys.fcntl(sys.stdin, sys.F_SETFL, termState)

}
