import "./sys"

module standard

proc exit[code:int]
{
    sys.exit(code)
}

proc write[msg:string]
{
    sys.write(sys.stdout, msg, msg.length)
}

proc write char[c:char]
{
    sys.write(sys.stdout, ->c, 1)
}

proc write number[number:int]
{
    if number == 0 {
        write char("0")
        return
    }

    if number < 0 {
        write char("-")
        number = 0 - number
    }

    // find highest decimal place
    var decimal place = 1
    while number > decimal place {
        decimal place *= 10
    }
    if number / decimal place == 0 {
        decimal place /= 10
    }

    // work our way down, printing along the way
    while decimal place > 0 {
        var digit = number / decimal place
        write char("0" + digit)
        number -= digit * decimal place
        decimal place /= 10
    }
}

proc write hex[number:int] {
    write char("0")
    write char("x")
    const lut = "0123456789ABCDEF"
    for var i = 60; i >= 0; i-=4 {
        write char(lut[(number>>i) & 0xF])
    }
}

proc write line[msg:string] {
    write(msg)
    write("\n")
}

proc strlen[str:cstring] -> int
{
    var len = 0
    while str[len] != 0 { len++ }
    return len
}

proc write cstring[str:cstring] {
    sys.write(sys.stdout, str, strlen(str))
}

proc assert[
    condition:bool      #callee span(message),
    message:string,
    call site:string    #call site
] {
    if condition { return }

    write(call site)
    write(" assertion failed: ")
    write(message)
    write("\n")
    exit(1)
}

proc panic[
    message:string,
    call site:string #call site
] {
    write(call site)
    write(" PANIC: ")
    write(message)
    write("\n")
    exit(1)
}

proc trace[
    it:any,
    call site:string #call site
] {
    write(call site)
    write(": ")
    println(it)
}

proc TODO[call site:string #call site]
{
    write(call site)
    write(" not implemented.\n")
    exit(1)
}

// reads into the input buffer from stdin
// returns a string containing the input
proc read[buffer:![]char] -> string
{
    var len = sys.read(sys.stdin, buffer, buffer.length)
    return string(buffer, len)
}


proc write file text base[filename:cstring, content:string, flags:int, mode: sys.mode_t] #private
{
    var fd = sys.open(filename, flags, mode)
    assert(fd>=0)

    sys.write(fd,content,content.length)

    var error = sys.close(fd)
    assert(error == 0)
}

proc write all text[filename:cstring, content:string]
{
    const flags = sys.O_CREAT|sys.O_WRONLY
    const mode = sys.S_IRUSR|sys.S_IWUSR

    sys.unlink(filename)
    write file text base(filename, content, flags, mode)
}

proc append text[filename:cstring, content:string]
{
    const flags = sys.O_CREAT|sys.O_WRONLY|sys.O_APPEND
    const mode = sys.S_IRUSR|sys.S_IWUSR

    write file text base(filename, content, flags, mode)
}

proc print[it:any] {
    // TODO: make an enum out of this 
    const tag void    = 0
    const tag int     = 1
    const tag bool    = 2
    const tag string  = 3
    const tag char    = 4
    const tag pointer = 5
    const tag array   = 6
    const tag struct  = 7
    const tag type    = 8
    const tag enum    = 9

    var d = it.data
    // TODO: fix pointer following for nested property access
    var t = it.type

    if t.kind == tag bool {
        // TODO: fix this not working with res:bool
        var res:int = <-d
        if res > 0 {
            write("true")
        } else {
            write("false")
        }
    } else if t.kind == tag int {
        write number(<-d)
    } else if t.kind == tag string {
        // write("\"")
        write(<-d)
        // write("\"")
    } else if t.kind == tag pointer {
        write("->")
        print(any(<-d, t.data.pointerData.to))
    } else if t.kind == tag array {
        write("[")
        var entries:[]void = <-d
        var entryType = t.data.arrayData.of
        var entrySize = entryType.size

        var i = 0
        while(i<entries.length) {
            if (i != 0) { write(", ") }
            var ptr = entries.buffer + (i * entrySize)
            print(any(ptr,entryType))
            i++
        }
        write("]")
    } else if t.kind == tag struct {
        var basePtr = d
        var fields = t.data.structData.fields

        write(t.name)
        write("{")
        each field,i : fields {
            if (i != 0) {
                write(", ")
            }
            var fieldPtr = basePtr + field.offset
            var fieldType = field.type
            write(field.name)
            write("=")
            print(any(fieldPtr, fieldType))
        }
        write("}")
    } else if t.kind == tag enum {
        write(t.name)
        write(".")
        var index:int = <-d
        var entries = t.data.enumData.entries
        assert(index<entries.length)
        // TODO: allow expressions like 'entries[index].name'
        var entry = entries[index]
        var fields = entry.fields
        write(entry.name)
        if fields.length > 0 {
            write("[")
            var basePtr=d
            each field,i : fields {
                if (i != 0) {
                    write(", ")
                }
                var fieldPtr = basePtr + field.offset
                var fieldType = field.type
                write(field.name)
                write("=")
                print(any(fieldPtr, fieldType))
            }
            write("]")
        }
    } else {
        write number(t.kind)
        assert(false, "Unsupported type tag")
    }
}

proc println[it:any] {
    print(it)
    write("\n")
}

proc printf[xs:[]any] {
    each x,i : xs {
        print(x)
        if i < (xs.length-1) {
            write(", ")
        }
    }
    write("\n")
}

// TODO: some allocation scheme so we can return this as a string
proc to json[it:any] {
    proc pad[padding:int] {
        for var i = 0; i < padding; i++ {
            write char(" ") 
        }
    }

    proc to json internal[it:any,padding:int,use padding:bool] {
        if use padding {
            pad(padding)
        }

        // TODO: make an enum out of this 
        const tag void    = 0
        const tag int     = 1
        const tag bool    = 2
        const tag string  = 3
        const tag char    = 4
        const tag pointer = 5
        const tag array   = 6
        const tag struct  = 7
        const tag type    = 8
        const tag enum    = 9

        var d = it.data
        // TODO: fix pointer following for nested property access
        var t = it.type

        if t.kind == tag int {
            write number(<-d)
        } else if t.kind == tag string {
            write("\"")
            write(<-d)
            write("\"")
        } else if t.kind == tag pointer {
            panic("pointers cannot be serialized")
        } else if t.kind == tag array {
            var entries:[]void = <-d
            var entryType = t.data.arrayData.of
            var entrySize = entryType.size
            var is complex = (entries.length > 12) || ((entryType.kind != tag int) && (entries.length > 1))

            // TODO: fix if and else statement having the same scope?
            var i = 0
            if is complex {
                write("[\n")

                while(i<entries.length) {
                    var ptr = entries.buffer + (i * entrySize)
                    to json internal(any(ptr,entryType),padding+4,true)
                    if i != (entries.length-1) {
                        write(",")
                    }
                    write("\n")
                    i++
                }
                write("]")
            } else {
                write("[")

                while(i<entries.length) {
                    var ptr = entries.buffer + (i * entrySize)
                    to json internal(any(ptr,entryType),padding,false)
                    if i != (entries.length-1) {
                        write(", ")
                    }
                    i++
                }
                write("]")
            }

        } else if t.kind == tag struct {
            var basePtr = d
            var fields = t.data.structData.fields
            // TODO: 'fix is complex = field.length>4' not working for some reason
            var is complex = false
            if fields.length > 4 {
                is complex = true
            } else {
                each field : fields {
                    var fieldType = field.type
                    if (field.name.length > 12) {
                        is complex = true
                        break
                    }
                    if (fieldType.kind != tag int) {
                        is complex = true
                        break
                    }
                }
            }

            if is complex {
                write("{\n")
                each field,i : fields {
                    var fieldPtr = basePtr + field.offset
                    var fieldType = field.type
                    pad(padding+4)
                    write("\"")
                    write(field.name)
                    write("\"")
                    write(": ")
                    to json internal(any(fieldPtr, fieldType), padding+4,false)
                    if (i != (fields.length-1)) {
                        write(",\n")
                    } else {
                        write("\n")
                    }
                }
                pad(padding)
                write("}")
            } else {
                write("{")
                each field,i : fields {
                    var fieldPtr = basePtr + field.offset
                    var fieldType = field.type
                    write("\"")
                    write(field.name)
                    write("\"")
                    write(": ")
                    to json internal(any(fieldPtr, fieldType), padding,false)
                    if (i != (fields.length-1)) {
                        write(", ")
                    }
                }
                write("}")
            }
        } else if t.kind == tag enum {
            // TODO: add cast so we can just cast(int, <-d)
            var index:int = <-d
            write number(index)
        } else {
            write number(t.kind)
            panic(": Unsupported type tag")
        }
    }

    to json internal(it,0,false)
    write("\n")
}


proc parse int[s:string] -> int {
    var num = 0
    each c : s {
        // TODO: get precedence working
        if (c < "0") || (c > "9") { break }
        num = (num * 10) + (c - "0")
    }
    return num
}

proc random range[from:int,to:int] -> int
{
    var value:int
    // TODO: pass proper flag?
    sys.getrandom(->value,sizeof(int),0)

    // TODO: make unsigned int work and remove this
    if value < 0 { value = -value }

    return (value % (to-from)) + from
}

module tui {
    proc clear[] {
        // goto 0,0; clear
        write("\x1B[H\x1B[J")
    }

    proc cursor to[x:int,y:int] {
        write("\x1B[")
        write number(y)
        write(";")
        write number(x)
        write("H")
    }
    module color {
        const black = "\x1B[0;30m"
        const red = "\x1B[0;31m"
        const green = "\x1B[0;32m"
        const yellow = "\x1B[0;33m"
        const blue = "\x1B[0;34m"
        const magenta = "\x1B[0;35m"
        const cyan = "\x1B[0;36m"
        const white = "\x1B[0;37m"
        const reset = "\x1B[0m"
    }
}
