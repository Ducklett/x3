import "./sys"

module standard {
    proc exit[code:int]
    {
        sys.exit(code)
    }

    proc write[msg:string]
    {
        sys.write(sys.stdout, msg, msg.length)
    }

    proc write char[c:char]
    {
        sys.write(sys.stdout, ->c, 1)
    }

    proc write number[number:int]
    {
        if number == 0 {
            write char("0")
            return
        }

        if number < 0 {
            write char("-")
            number = 0 - number
        }

        ((find highest decimal place))
        var decimal place = 1
        while number > decimal place {
            decimal place *= 10
        }
        if number / decimal place == 0 {
            decimal place /= 10
        }

        ((work our way down, printing along the way))
        while decimal place > 0 {
            var digit = number / decimal place
            write char("0" + digit)
            number -= digit * decimal place
            decimal place /= 10
        }
    }

    proc write hex[number:int] {
        write char("0")
        write char("x")
        ((TODO: switch to normal comment syntax, this bracket stuff doesn't mesh well with parenthesized expressions))
        const lut = "0123456789ABCDEF"
        for var i = 60; i >= 0; i-=4 {
            write char(lut[(number>>i) & 0xF])
        }
    }

    proc write line[msg:string] {
        write(msg)
        write("\n")
    }

    proc strlen[str:cstring] -> int
    {
        var len = 0
        while str[len] != 0 { len++ }
        return len
    }

    proc write cstring[str:cstring] {
        sys.write(sys.stdout, str, strlen(str))
    }

    proc assert[
        condition:bool      #callee span(message),
        message:string,
        call site:string    #call site
    ] {
        if condition { return }

        write(call site)
        write(" assertion failed: ")
        write(message)
        write("\n")
        exit(1)
    }

    proc panic[
        message:string,
        call site:string #call site
    ] {
        write(call site)
        write(" PANIC: ")
        write(message)
        write("\n")
        exit(1)
    }

    proc TODO[call site:string #call site']
    {
        write(call site)
        write(" not implemented.\n")
        exit(1)
    }

    ((reads into the input buffer from stdin))
    ((returns a string containing the input))
    proc read[buffer:![]char] -> string
    {
        var len = sys.read(sys.stdin, buffer, buffer.length)
        return string(buffer, len)
    }


    proc write file text base[filename:cstring, content:string, flags:int, mode: sys.mode_t] #private
    {
        ((TODO: support for non-constexpr const declarations))
        ((TODO: error checking))
        var fd = sys.open(filename, flags, mode)
        assert(fd>=0)

        sys.write(fd,content,content.length)

        var error = sys.close(fd)
        assert(error == 0)
    }

    proc write all text[filename:cstring, content:string]
    {
        const flags = sys.O_CREAT|sys.O_WRONLY
        const mode = sys.S_IRUSR|sys.S_IWUSR

        sys.unlink(filename)
        write file text base(filename, content, flags, mode)
    }

    proc append text[filename:cstring, content:string]
    {
        const flags = sys.O_CREAT|sys.O_WRONLY|sys.O_APPEND
        const mode = sys.S_IRUSR|sys.S_IWUSR

        write file text base(filename, content, flags, mode)
    }

    proc parse int[s:string] -> int {
        var num = 0
        each c : s {
            ((TODO: get precedence working))
            if (c < "0") || (c > "9") { break }
            num = (num * 10) + (c - "0")
        }
        return num
    }

    proc random range[from:int,to:int] -> int
    {
        var value:int
        ((TODO: pass proper flag?))
        sys.getrandom(->value,8,0)

        ((TODO: make unsigned int work and remove this))
        if value < 0 { value = -value }

        return (value % (to-from)) + from
    }
}
